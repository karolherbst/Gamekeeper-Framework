/*
 * C++ Standard Library Boost Wrapper
 * Boost fallbacks for missing C++11 functionality
 *
 * Written in 2013 by Karol Herbst <gamekeeper@karolherbst.de>
 * To the extent possible under law, the author(s) have dedicated all copyright
 * and related and neighboring rights to this software to the public domain
 * worldwide. This software is distributed without any warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication along with
 * this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

#ifndef STD_COMPAT_MUTEX
#define STD_COMPAT_MUTEX 1

#include <mutex>

#if defined(__GNUC__) && !defined(__clang__) && (!defined(_GLIBCXX_HAS_GTHREADS) || !defined(_GLIBCXX_USE_C99_STDINT_TR1))

#include <chrono>

#include <boost/chrono/time_point.hpp>
#include <boost/ratio/ratio.hpp>
#include <boost/thread/mutex.hpp>

namespace std
{
	class mutex : public boost::mutex{};
	class timed_mutex : public boost::timed_mutex
	{
	public:
		template <class Clock, class Duration>
		struct BoostStdClockBridge
		{
			typedef chrono::time_point<Clock, Duration> StdTP;

			typedef typename Duration::rep rep;
			typedef boost::ratio<StdTP::period::num, StdTP::period::den> period;
			typedef boost::chrono::duration<typename StdTP::rep, period> duration;
			typedef boost::chrono::time_point<BoostStdClockBridge<Clock, Duration>> time_point;

			static constexpr bool is_steady = Clock::is_steady;
			inline static time_point now() noexcept
			{
				return time_point(duration(Clock::now().time_since_epoch().count()));
			}
		};
		
		template <class Clock, class Duration>
		inline bool try_lock_until (const chrono::time_point<Clock,Duration>& abs_time)
		{
			typedef BoostStdClockBridge<Clock, Duration> BClock;
			return boost::timed_mutex::try_lock_until
			(
				typename BClock::time_point
				(
					typename BClock::duration(abs_time.time_since_epoch().count())
				)
			);
		}
	};
}

#endif

#endif //STD_COMPAT_MUTEX
